<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Getting Started with Keras on TensorFlow for R</title><link>/guide/keras/</link><description>Recent content in Getting Started with Keras on TensorFlow for R</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="/guide/keras/index.xml" rel="self" type="application/rss+xml"/><item><title>Frequently Asked Questions</title><link>/guide/keras/faq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/guide/keras/faq/</guid><description>How should I cite Keras? Please cite Keras in your publications if it helps your research. Here is an example BibTeX entry:
@misc{chollet2017kerasR, title={R Interface to Keras}, author={Chollet, Fran\c{c}ois and Allaire, JJ and others}, year={2017}, publisher={GitHub}, howpublished={\url{https://github.com/rstudio/keras}}, } How can I run Keras on a GPU? Note that installation and configuration of the GPU-based backends can take considerably more time and effort. So if you are just getting started with Keras you may want to stick with the CPU version initially, then install the appropriate GPU version once your training becomes more computationally demanding.</description></item><item><title>Guide to Keras Basics</title><link>/guide/keras/guide_keras/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/guide/keras/guide_keras/</guid><description>Keras is a high-level API to build and train deep learning models. It’s used for fast prototyping, advanced research, and production, with three key advantages:
User friendly
Keras has a simple, consistent interface optimized for common use cases. It provides clear and actionable feedback for user errors. Modular and composable
Keras models are made by connecting configurable building blocks together, with few restrictions. Easy to extend</description></item><item><title>Guide to the Functional API</title><link>/guide/keras/functional_api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/guide/keras/functional_api/</guid><description>The Keras functional API is the way to go for defining complex models, such as multi-output models, directed acyclic graphs, or models with shared layers.
This guide assumes that you are already familiar with the Sequential model.
Let’s start with something simple.
First example: a densely-connected network The Sequential model is probably a better choice to implement such a network, but it helps to start with something really simple.</description></item><item><title>Guide to the Sequential Model</title><link>/guide/keras/sequential_model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/guide/keras/sequential_model/</guid><description>Defining a Model The sequential model is a linear stack of layers.
You create a sequential model by calling the keras_model_sequential() function then a series of layer functions:
library(keras) model &amp;lt;-keras_model_sequential() model %&amp;gt;% layer_dense(units = 32, input_shape = c(784)) %&amp;gt;% layer_activation(&#39;relu&#39;) %&amp;gt;% layer_dense(units = 10) %&amp;gt;% layer_activation(&#39;softmax&#39;) Note that Keras objects are modified in place which is why it’s not necessary for model to be assigned back to after the layers are added.</description></item><item><title>Mixed Precision Training</title><link>/guide/keras/mixed_precision/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/guide/keras/mixed_precision/</guid><description>Overview Mixed precision is the use of both 16-bit and 32-bit floating-point types in a model during training to make it run faster and use less memory. By keeping certain parts of the model in the 32-bit types for numeric stability, the model will have a lower step time and train equally as well in terms of the evaluation metrics such as accuracy. This guide describes how to use the experimental Keras mixed precision API to speed up your models.</description></item><item><title>Saving and serializing models</title><link>/guide/keras/saving_serializing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/guide/keras/saving_serializing/</guid><description>This tutorial is an R translation of this page available in the official TensorFlow documentation.
The first part of this guide covers saving and serialization for Sequential models and models built using the Functional API. The saving and serialization APIs are the exact same for both of these types of models.
Saving for custom subclasses of Model is covered in the section “Saving Subclassed Models”. The APIs in this case are slightly different than for Sequential or Functional models.</description></item><item><title>Training Callbacks</title><link>/guide/keras/training_callbacks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/guide/keras/training_callbacks/</guid><description>Overview A callback is a set of functions to be applied at given stages of the training procedure. You can use callbacks to get a view on internal states and statistics of the model during training. You can pass a list of callbacks (as the keyword argument callbacks) to the fit() function. The relevant methods of the callbacks will then be called at each stage of the training.
For example:</description></item><item><title>Training Visualization</title><link>/guide/keras/training_visualization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/guide/keras/training_visualization/</guid><description>Overview There are a number of tools available for visualizing the training of Keras models, including:
A plot method for the Keras training history returned from fit().
Real time visualization of training metrics within the RStudio IDE.
Integration with the TensorBoard visualization tool included with TensorFlow. Beyond just training metrics, TensorBoard has a wide variety of other visualizations available including the underlying TensorFlow graph, gradient histograms, model weights, and more.</description></item><item><title>Using Pre-Trained Models</title><link>/guide/keras/applications/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/guide/keras/applications/</guid><description>Applications Keras Applications are deep learning models that are made available alongside pre-trained weights. These models can be used for prediction, feature extraction, and fine-tuning.
Weights are downloaded automatically when instantiating a model. They are stored at ~/.keras/models/.
The following image classification models (with weights trained on ImageNet) are available:
Xception VGG16 VGG19 ResNet50 InceptionV3 InceptionResNetV2 MobileNet MobileNetV2 DenseNet NASNet All of these architectures are compatible with all the backends (TensorFlow, Theano, and CNTK), and upon instantiation the models will be built according to the image data format set in your Keras configuration file at ~/.</description></item><item><title>Writing Custom Keras Layers</title><link>/guide/keras/custom_layers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/guide/keras/custom_layers/</guid><description>If the existing Keras layers don’t meet your requirements you can create a custom layer. For simple, stateless custom operations, you are probably better off using layer_lambda() layers. But for any custom operation that has trainable weights, you should implement your own layer.
The example below illustrates the skeleton of a Keras custom layer. The mnist_antirectifier example includes another demonstration of creating a custom layer.
KerasLayer R6 Class To create a custom Keras layer, you create an R6 class derived from KerasLayer.</description></item><item><title>Writing Custom Keras Models</title><link>/guide/keras/custom_models/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/guide/keras/custom_models/</guid><description>Overview In addition to sequential models and models created with the functional API, you may also define models by defining a custom call() (forward pass) operation.
To create a custom Keras model, you call the keras_model_custom() function, passing it an R function which in turn returns another R function that implements the custom call() (forward pass) operation. The R function you pass takes a model argument, which provides access to the underlying Keras model object should you need it.</description></item></channel></rss>